---
title: Identity
description: API reference for the identity package
---

<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# identity

```go
import "github.com/eljojo/nara/identity"
```

## Index

- [Constants](<#constants>)
- [func CollectSoulFragments\(\) string](<#CollectSoulFragments>)
- [func ComputeNaraID\(soulBase58 string, name types.NaraName\) \(types.NaraID, error\)](<#ComputeNaraID>)
- [func ComputeTag\(seed \[SeedLen\]byte, name types.NaraName\) \[TagLen\]byte](<#ComputeTag>)
- [func FormatPublicKey\(pub ed25519.PublicKey\) string](<#FormatPublicKey>)
- [func FormatSoul\(soul SoulV1\) string](<#FormatSoul>)
- [func Gemstone\(name string, soul string\) string](<#Gemstone>)
- [func GenerateName\(id string\) string](<#GenerateName>)
- [func HashBytes\(data \[\]byte\) \[\]byte](<#HashBytes>)
- [func HashHardware\(fragments string\) \[\]byte](<#HashHardware>)
- [func IsGenericHostname\(hostname string\) bool](<#IsGenericHostname>)
- [func NameFromSoul\(soul SoulV1\) types.NaraName](<#NameFromSoul>)
- [func ParsePublicKey\(s string\) \(ed25519.PublicKey, error\)](<#ParsePublicKey>)
- [func SignContent\(s Signable, kp NaraKeypair\) string](<#SignContent>)
- [func ValidateBond\(soul SoulV1, name types.NaraName\) bool](<#ValidateBond>)
- [func VerifyContent\(s Signable, publicKey \[\]byte, signature string\) bool](<#VerifyContent>)
- [func VerifySignature\(publicKey ed25519.PublicKey, message, signature \[\]byte\) bool](<#VerifySignature>)
- [func VerifySignatureBase64\(publicKey \[\]byte, message \[\]byte, signatureBase64 string\) bool](<#VerifySignatureBase64>)
- [type EncryptionKeypair](<#EncryptionKeypair>)
  - [func DeriveEncryptionKeys\(privateKey ed25519.PrivateKey\) EncryptionKeypair](<#DeriveEncryptionKeys>)
  - [func \(kp EncryptionKeypair\) DecryptForSelf\(nonce, ciphertext \[\]byte\) \(\[\]byte, error\)](<#EncryptionKeypair.DecryptForSelf>)
  - [func \(kp EncryptionKeypair\) EncryptForSelf\(plaintext \[\]byte\) \(nonce, ciphertext \[\]byte, err error\)](<#EncryptionKeypair.EncryptForSelf>)
- [type IdentityResult](<#IdentityResult>)
  - [func DetermineIdentity\(nameArg types.NaraName, soulArg, hostname string, hwFingerprint \[\]byte\) IdentityResult](<#DetermineIdentity>)
- [type NaraKeypair](<#NaraKeypair>)
  - [func DeriveKeypair\(soul SoulV1\) NaraKeypair](<#DeriveKeypair>)
  - [func \(kp NaraKeypair\) Open\(nonce, ciphertext \[\]byte\) \(\[\]byte, error\)](<#NaraKeypair.Open>)
  - [func \(kp NaraKeypair\) Seal\(plaintext \[\]byte\) \(nonce, ciphertext \[\]byte, err error\)](<#NaraKeypair.Seal>)
  - [func \(kp NaraKeypair\) Sign\(message \[\]byte\) \[\]byte](<#NaraKeypair.Sign>)
  - [func \(kp NaraKeypair\) SignBase64\(message \[\]byte\) string](<#NaraKeypair.SignBase64>)
- [type Signable](<#Signable>)
- [type SoulV1](<#SoulV1>)
  - [func NativeSoulCustom\(hwFingerprint \[\]byte, name types.NaraName\) SoulV1](<#NativeSoulCustom>)
  - [func NativeSoulGenerated\(hwFingerprint \[\]byte\) SoulV1](<#NativeSoulGenerated>)
  - [func ParseSoul\(s string\) \(SoulV1, error\)](<#ParseSoul>)


## Constants

<a name="SeedLen"></a>

```go
const (
    SeedLen = 32
    TagLen  = 8
    SoulLen = SeedLen + TagLen // 40 bytes total
)
```

<a name="CollectSoulFragments"></a>
## func [CollectSoulFragments](<https://github.com/eljojo/nara/blob/main/identity/names.go#L60>)

```go
func CollectSoulFragments() string
```



<a name="ComputeNaraID"></a>
## func [ComputeNaraID](<https://github.com/eljojo/nara/blob/main/identity/detection.go#L26>)

```go
func ComputeNaraID(soulBase58 string, name types.NaraName) (types.NaraID, error)
```

ComputeNaraID computes a deterministic, stable ID from soul and name. This allows distinguishing naras with the same name but different souls.

Computation: ID = Base58\(SHA256\(soul\_bytes || name\_bytes\)\)

Where:

- soul\_bytes: Base58\-decoded 40\-byte soul \(32\-byte seed \+ 8\-byte tag\)
- name\_bytes: UTF\-8 encoded name string
- Result: Base58\-encoded hash for human readability

The ID is:

- Deterministic: Same soul\+name always produces same ID
- Stable: Survives restarts \(doesn't depend on ephemeral keypairs\)
- Unique: Different souls with same name produce different IDs

<a name="ComputeTag"></a>
## func [ComputeTag](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L57>)

```go
func ComputeTag(seed [SeedLen]byte, name types.NaraName) [TagLen]byte
```

ComputeTag computes the HMAC tag that bonds a seed to a name

<a name="FormatPublicKey"></a>
## func [FormatPublicKey](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L49>)

```go
func FormatPublicKey(pub ed25519.PublicKey) string
```

FormatPublicKey encodes a public key as Base64 for transmission

<a name="FormatSoul"></a>
## func [FormatSoul](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L36>)

```go
func FormatSoul(soul SoulV1) string
```

FormatSoul encodes a SoulV1 as a Base58 string

<a name="Gemstone"></a>
## func [Gemstone](<https://github.com/eljojo/nara/blob/main/identity/names.go#L34>)

```go
func Gemstone(name string, soul string) string
```



<a name="GenerateName"></a>
## func [GenerateName](<https://github.com/eljojo/nara/blob/main/identity/names.go#L42>)

```go
func GenerateName(id string) string
```



<a name="HashBytes"></a>
## func [HashBytes](<https://github.com/eljojo/nara/blob/main/identity/names.go#L95>)

```go
func HashBytes(data []byte) []byte
```

HashBytes creates a SHA256 hash of the given data

<a name="HashHardware"></a>
## func [HashHardware](<https://github.com/eljojo/nara/blob/main/identity/names.go#L90>)

```go
func HashHardware(fragments string) []byte
```

HashHardware creates a hardware fingerprint hash

<a name="IsGenericHostname"></a>
## func [IsGenericHostname](<https://github.com/eljojo/nara/blob/main/identity/names.go#L104>)

```go
func IsGenericHostname(hostname string) bool
```



<a name="NameFromSoul"></a>
## func [NameFromSoul](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L111>)

```go
func NameFromSoul(soul SoulV1) types.NaraName
```

NameFromSoul derives the generated name from a soul's seed

<a name="ParsePublicKey"></a>
## func [ParsePublicKey](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L54>)

```go
func ParsePublicKey(s string) (ed25519.PublicKey, error)
```

ParsePublicKey decodes a Base64 public key

<a name="SignContent"></a>
## func [SignContent](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L103>)

```go
func SignContent(s Signable, kp NaraKeypair) string
```

SignContent signs a Signable's content directly \(no pre\-hashing\). This matches the existing signing pattern used throughout the codebase. Returns a base64\-encoded Ed25519 signature.

<a name="ValidateBond"></a>
## func [ValidateBond](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L68>)

```go
func ValidateBond(soul SoulV1, name types.NaraName) bool
```

ValidateBond checks if a soul is validly bonded to a name

<a name="VerifyContent"></a>
## func [VerifyContent](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L109>)

```go
func VerifyContent(s Signable, publicKey []byte, signature string) bool
```

VerifyContent verifies a signature against a Signable's content. The signature should have been created with SignContent.

<a name="VerifySignature"></a>
## func [VerifySignature](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L66>)

```go
func VerifySignature(publicKey ed25519.PublicKey, message, signature []byte) bool
```

VerifySignature verifies a signature against a public key and message

<a name="VerifySignatureBase64"></a>
## func [VerifySignatureBase64](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L83>)

```go
func VerifySignatureBase64(publicKey []byte, message []byte, signatureBase64 string) bool
```

VerifySignatureBase64 verifies a base64\-encoded signature

<a name="EncryptionKeypair"></a>
## type [EncryptionKeypair](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L115-L117>)

EncryptionKeypair holds a symmetric key derived from an Ed25519 private key Used for self\-encryption \(encrypt data that only the owner can decrypt\)

```go
type EncryptionKeypair struct {
    SymmetricKey []byte // 32-byte key for XChaCha20-Poly1305
}
```

<a name="DeriveEncryptionKeys"></a>
### func [DeriveEncryptionKeys](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L121>)

```go
func DeriveEncryptionKeys(privateKey ed25519.PrivateKey) EncryptionKeypair
```

DeriveEncryptionKeys derives a symmetric encryption key from an Ed25519 private key Uses HKDF with SHA\-256 to derive a 32\-byte key for XChaCha20\-Poly1305

<a name="EncryptionKeypair.DecryptForSelf"></a>
### func \(EncryptionKeypair\) [DecryptForSelf](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L162>)

```go
func (kp EncryptionKeypair) DecryptForSelf(nonce, ciphertext []byte) ([]byte, error)
```

DecryptForSelf decrypts ciphertext using XChaCha20\-Poly1305

<a name="EncryptionKeypair.EncryptForSelf"></a>
### func \(EncryptionKeypair\) [EncryptForSelf](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L143>)

```go
func (kp EncryptionKeypair) EncryptForSelf(plaintext []byte) (nonce, ciphertext []byte, err error)
```

EncryptForSelf encrypts plaintext using XChaCha20\-Poly1305 with a random nonce Returns the nonce and ciphertext separately so the nonce can be stored with the payload

<a name="IdentityResult"></a>
## type [IdentityResult](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L27-L33>)



```go
type IdentityResult struct {
    Name        types.NaraName // Changed from string
    Soul        SoulV1
    ID          types.NaraID // Nara ID: deterministic hash of soul+name
    IsValidBond bool
    IsNative    bool
}
```

<a name="DetermineIdentity"></a>
### func [DetermineIdentity](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L117>)

```go
func DetermineIdentity(nameArg types.NaraName, soulArg, hostname string, hwFingerprint []byte) IdentityResult
```

DetermineIdentity resolves name and soul from arguments and hardware. hostname should be the short hostname \(no domain suffix\).

<a name="NaraKeypair"></a>
## type [NaraKeypair](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L17-L21>)

NaraKeypair holds an Ed25519 keypair derived from a soul

```go
type NaraKeypair struct {
    PrivateKey    ed25519.PrivateKey
    PublicKey     ed25519.PublicKey
    EncryptionKey EncryptionKeypair // Cached encryption key for self-encryption
}
```

<a name="DeriveKeypair"></a>
### func [DeriveKeypair](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L26>)

```go
func DeriveKeypair(soul SoulV1) NaraKeypair
```

DeriveKeypair deterministically derives an Ed25519 keypair from a soul's seed. The soul's 32\-byte seed is exactly Ed25519's SeedSize, so same soul = same keypair. Also derives and caches the encryption key for efficiency.

<a name="NaraKeypair.Open"></a>
### func \(NaraKeypair\) [Open](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L188>)

```go
func (kp NaraKeypair) Open(nonce, ciphertext []byte) ([]byte, error)
```

Open decrypts ciphertext using the cached encryption key. Convenience method on NaraKeypair that delegates to EncryptionKey.

<a name="NaraKeypair.Seal"></a>
### func \(NaraKeypair\) [Seal](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L182>)

```go
func (kp NaraKeypair) Seal(plaintext []byte) (nonce, ciphertext []byte, err error)
```

Seal encrypts plaintext using the cached encryption key. Convenience method on NaraKeypair that delegates to EncryptionKey.

<a name="NaraKeypair.Sign"></a>
### func \(NaraKeypair\) [Sign](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L39>)

```go
func (kp NaraKeypair) Sign(message []byte) []byte
```

Sign signs a message with the keypair's private key

<a name="NaraKeypair.SignBase64"></a>
### func \(NaraKeypair\) [SignBase64](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L44>)

```go
func (kp NaraKeypair) SignBase64(message []byte) string
```

SignBase64 signs a message and returns the signature as a base64 string

<a name="Signable"></a>
## type [Signable](<https://github.com/eljojo/nara/blob/main/identity/crypto.go#L94-L98>)

Signable is implemented by types that can produce canonical content for signing. This provides a unified interface for cryptographic signing across different message types.

```go
type Signable interface {
    // SignableContent returns the canonical string representation for signing.
    // The string should be deterministic and include all fields that need authentication.
    SignableContent() string
}
```

<a name="SoulV1"></a>
## type [SoulV1](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L22-L25>)



```go
type SoulV1 struct {
    Seed [SeedLen]byte
    Tag  [TagLen]byte
}
```

<a name="NativeSoulCustom"></a>
### func [NativeSoulCustom](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L77>)

```go
func NativeSoulCustom(hwFingerprint []byte, name types.NaraName) SoulV1
```

NativeSoulCustom generates a deterministic soul for a custom name on given hardware

<a name="NativeSoulGenerated"></a>
### func [NativeSoulGenerated](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L92>)

```go
func NativeSoulGenerated(hwFingerprint []byte) SoulV1
```

NativeSoulGenerated generates a deterministic soul for generated\-name mode

<a name="ParseSoul"></a>
### func [ParseSoul](<https://github.com/eljojo/nara/blob/main/identity/soul.go#L44>)

```go
func ParseSoul(s string) (SoulV1, error)
```

ParseSoul decodes a Base58 string into a SoulV1

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
